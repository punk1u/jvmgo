<center><b>类和对象</b></center>



# 类和对象

本章将实现线程共享的运行时数据区，包括方法区和运行时常量池。



## 方法区

方法区是运行时数据区的一块逻辑区域，由多个线程共享。方法区主要存放从class文件获取的类信息。此外，类变量也存放在方法区中。当Java虚拟机第一次使用某个类时，它会搜索类路径，找到相应的class文件，然后读取并解析class文件，把相关信息放进方法区。至于方法区到底位于何处，是固定大小还是动态调整，是否参与垃圾回收，以及如何在方法区内存放类数据等，Java虚拟机规范并没有明确规定。



***需要放进方法区的信息有类信息、字段信息、方法信息和其他信息。***



### 类信息

包含类的访问标志、类名、超类名、接口名和运行时常量池指针、字段表、方法表等。



### 字段信息

字段和方法都属于类的成员，它们有一些相同的信息（访问标志、名字、描述符）。



### 方法信息

方法比字段稍微复杂一些，因为方法中有字节码。



### 其他信息

类加载器指针、类的超类和接口指针。类变量和实例变量占据的空间大小，存放静态变量。





## 运行时常量池

运行时常量池主要存放两类信息：字面量（literal）和符号引用（symbolic reference）。字面量包括整数、浮点数和字符串字面量；符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。



## 类加载器





## 类和对象相关指令

new指令用来创建类实例；putstatic和getstatic指令用于存取静态变量；putfield和getfield用于存取实例变量；instanceof和checkcast指令用于判断对象是否属于某种类型；ldc系列指令把运行时常量池中的常量推到操作数栈顶。



### new指令

new指令专门用来创建类实例。数组由专门的指令创建。



### putstatic和getstatic指令

putstatic指令给类的某个静态变量赋值，它需要两个操作数。第一个操作数是uint16索引，来自字节码。通过这个索引可以从当前类的运行时常量池中找到一个字段符号引用，解析这个符号引用就可以知道要给类的哪个静态变量赋值。第二个操作数是要赋给静态变量的值，从操作数栈中弹出。



getstatic指令和putstatic正好相反，它取出类的某个静态变量值，然后推入栈顶。



### putfield和getfield指令

putfield指令给实例变量赋值，它需要三个操作数。前两个操作数是常量池索引和变量值，用法和putstatic一样。第三个操作数是对象引用，从操作数栈中弹出。



### instanceof和checkcast指令

instanceof指令判断对象是否是某个类的实例（或者对象的类是否实现了某个接口），并把结果推入操作数栈。



checkcast指令和instanceof指令很像，区别在于：instanceof指令会改变操作数栈（弹出对象引用，推入判断结果）；checkcast则不改变操作数栈（如果判断失败，直接抛出ClassCastException异常）。



### ldc指令

ldc系列指令从运行时常量池中加载常量值，并把它推入操作数栈。ldc系列指令属于常量类指令，共3条。其中ldc和ldc_w指令用于加载int、float和字符串常量，java.lang.Class实例或者MethodType和MethodHandle实例。ldc2_w指令用于加载long和double常量。ldc和ldc_w指令的区别仅在于操作数的宽度。



